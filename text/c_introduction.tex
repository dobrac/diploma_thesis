Having a readily available client implementation and documentation for a server API significantly aids in testing and development.
However, implementing clients can be a time-consuming effort.
To address this, generic clients are often employed.
Swagger\footnote{\url{https://swagger.io/}} is a popular choice for RESTful APIs, while GraphiQL\footnote{\url{https://github.com/graphql/graphiql}} often serves this purpose in the GraphQL world.
There is an evident need for a similarly streamlined tool within the gRPC ecosystem.

While gRPC documentation tools exist, they often lack the user-friendliness found in their REST or GraphQL counterparts.
These solutions may require separate servers and sometimes have limited support for comprehensively documenting services, calls, and types.

The central aim of this work is to design and implement a static web presentation generator focused on user-friendly gRPC API documentation.
Input will consist of Protobuf Buffer files that describe the services, calls, and types.
The desired output is a static HTML page that provides clear documentation and the ability to directly execute gRPC-web API calls (assuming the API supports gRPC-web).

I have chosen this topic because I believe I can offer a solution that will alleviate the challenges associated with documenting gRPC services.
This is particularly relevant for developers who primarily work with RESTful APIs.

The thesis is divided into four main parts.
The first part focuses on analyzing existing solutions.
Subsequent parts cover design, implementation, and testing.

In the analysis phase, I will examine the features present in existing gRPC documentation solutions and compare them to similar tools designed for RESTful and GraphQL APIs.
Based on the insights gained, I will define the specific requirements and use cases for the static web presentation generator.

In the design chapter, I will present a solution that leverages a static web page and tools for converting gRPC API definitions into a format readily understood by the web page.
I will also delve into the options and potential limitations of using gRPC vs gRPC-web.
Additionally, I will explore and design a mechanism to obtain a gRPC API definition using gRPC reflection.

The implementation chapter will address the selection of an appropriate technology stack, the implementation of the designed solution, and the overall architecture of the application.
I will discuss any challenges encountered during implementation and the solutions devised.
This chapter will conclude with a review of the licenses associated with any external libraries used.

Finally, the testing chapter will cover both manual and automated testing strategies.
Automated testing will be conducted utilizing unit tests.
Manual testing will be performed through user testing, with a strong emphasis on evaluating the user-friendliness of the application.